<!-- -*- coding: utf-8 -*- -->
# POSIX 形式と IANA タイムゾーンデータベース形式双方の文字列を扱うことができるタイムゾーンライブラリ for C++11

[ Japanese (日本語) / [English](./README.md) ]

[https://github.com/trueroad/integrated_tz](https://github.com/trueroad/integrated_tz)

このライブラリは POSIX 形式（ `JST-9` のような形式）と
IANA タイムゾーンデータベース形式（ `Asia/Tokyo` のような形式）双方の
文字列を扱うことができるタイムゾーンライブラリです。
POSIX の `tzset ()` や `localtime ()` などとは異なり、
複数のタイムゾーンを同時に扱うことができます。
私が以前、
"[How to use POSIX-style environment variable `TZ` #258 
](https://github.com/HowardHinnant/date/issues/258#issuecomment-348945417)"
へ投稿したコードを改良したもので、ベースとして
[https://github.com/HowardHinnant/date](https://github.com/HowardHinnant/date)
を使っています。

目指したのは、

* 標準コマンドと同様に環境変数 `TZ` でタイムゾーンが指定できる
* 複数のタイムゾーンを同時に扱うことができる（環境変数以外でも指定できる）
* モダンな C++ に合う

です。

## サンプルをビルドする

サンプルをビルドする方法には 2 通りあります。

### 手動コンパイル

サンプルは下記のようなコマンドでビルドできます。
環境によっては異なるコマンドやオプションが必要になる場合があります。

#### シンプルなサンプル

```
$ g++ -std=gnu++11 -c -DUSE_AUTOLOAD=0 -DHAS_REMOTE_API=0 -DUSE_OS_TZDB=1 \
	tz/tz.cpp
$ g++ -std=gnu++11 -o sample sample.cc tz.o
```

#### 複数タイムゾーンのサンプル

```
$ g++ -std=gnu++11 -c -DUSE_AUTOLOAD=0 -DHAS_REMOTE_API=0 -DUSE_OS_TZDB=1 \
	tz/tz.cpp
$ g++ -std=gnu++11 -o sample-multiple sample-multiple.cc tz.o
```

### Autotools

本ライブラリそのものは Autotools 不要ですが、
Autotools を使うと以下のコマンドで簡単にビルドできます。

```
$ ./autogen.sh
$ ./configure
$ make
```

## 使い方

`integrated_tz.hh`, `integrated_tz_private.hh`,
`tz/ptz.h`, `tz/tz.cpp`,
`tz/date/date.h`, `tz/tz.h`, `tz_private.h`
をプロジェクトのディレクトリにコピーしてください。
`tz/tz.cpp`　をプロジェクトのソースコードに追加してください。

### シンプルなサンプル

以下は [sample.cc](./sample.cc) からの抜粋です。
ポイントは
`integrated_tz::time_zone`
クラスのインスタンス
`itz`
を作っているところです。これは
[https://github.com/HowardHinnant/date](https://github.com/HowardHinnant/date)
の `time_zone` クラスのインスタンスと同様の使い方ができます。

```c++
#include "integrated_tz.hh"

#include <chrono>
#include <iostream>
#include <sstream>
#include <string>

int main (int argc, char *argv[])
{
  auto tp {std::chrono::system_clock::now ()};

  if (argc > 1)
    {
      std::istringstream in {argv[1]};
      in >> date::parse ("%FT%T%Ez", tp); // RFC3339
      if (in.fail ())
        {
          in.clear ();
          in.seekg (0, in.beg);
          in >> date::parse ("%a, %d %b %Y %T %z", tp); // RFC2822
        }
    }

  integrated_tz::time_zone itz; // Current local time zone
  auto zt {date::make_zoned (&itz, tp)};

  std::cout << "zoned_time:" << std::endl
            << "    " << zt << std::endl;
  std::cout << "RFC3339 (zoned):" << std::endl
            << "    " << date::format ("%FT%T%Ez", zt) << std::endl;

  auto st {zt.get_sys_time ()};
  std::cout << "RFC3339 (UTC):" << std::endl
            << "    " << date::format ("%FT%T%Ez", st) << std::endl
            << "    " << date::format ("%FT%TZ", st) << std::endl;

  return 0;
}
```

以下、いくつかの出力例です。

コマンドラインオプションを何もつけないと、
現在時刻を現在のタイムゾーンと UTC の
いくつかのフォーマットで表示します。

```
$ ./sample
zoned_time:
    2018-08-19 08:54:30.737084100 JST
RFC3339 (zoned):
    2018-08-19T08:54:30.737084100+09:00
RFC3339 (UTC):
    2018-08-18T23:54:30.737084100+00:00
    2018-08-18T23:54:30.737084100Z

```

コマンドラインオプションで RFC3339 date-time フォーマットの時刻を指定すると、
その時刻を現在のタイムゾーンと UTC の
いくつかのフォーマットで表示します。

```
$ ./sample 1951-08-01T12:34:56+09:00
zoned_time:
    1951-08-01 12:34:56.000000000 JST
RFC3339 (zoned):
    1951-08-01T12:34:56.000000000+09:00
RFC3339 (UTC):
    1951-08-01T03:34:56.000000000+00:00
    1951-08-01T03:34:56.000000000Z

```

環境変数 `TZ` の設定でタイムゾーンを指定できます。
POSIX 形式と IANA タイムゾーンデータベース形式双方を使うことができます。
`JST-9` だとサマータイムの指定がないため、
2018 年も 1951 年も JST で +09:00 になっていますが、
`Asia/Tokyo` だとデータベースのサマータイム情報が使われるので、
1951 年は JDT で +10:00 になっています。

```
$ TZ=JST-9 ./sample
zoned_time:
    2018-08-19 08:55:48.481978300 JST
RFC3339 (zoned):
    2018-08-19T08:55:48.481978300+09:00
RFC3339 (UTC):
    2018-08-18T23:55:48.481978300+00:00
    2018-08-18T23:55:48.481978300Z

$ TZ=Asia/Tokyo ./sample
zoned_time:
    2018-08-19 08:55:57.365413700 JST
RFC3339 (zoned):
    2018-08-19T08:55:57.365413700+09:00
RFC3339 (UTC):
    2018-08-18T23:55:57.365413700+00:00
    2018-08-18T23:55:57.365413700Z

$ TZ=JST-9 ./sample 1951-08-01T12:34:56+09:00
zoned_time:
    1951-08-01 12:34:56.000000000 JST
RFC3339 (zoned):
    1951-08-01T12:34:56.000000000+09:00
RFC3339 (UTC):
    1951-08-01T03:34:56.000000000+00:00
    1951-08-01T03:34:56.000000000Z

$ TZ=Asia/Tokyo ./sample 1951-08-01T12:34:56+09:00
zoned_time:
    1951-08-01 13:34:56.000000000 JDT
RFC3339 (zoned):
    1951-08-01T13:34:56.000000000+10:00
RFC3339 (UTC):
    1951-08-01T03:34:56.000000000+00:00
    1951-08-01T03:34:56.000000000Z

```

### 複数タイムゾーンのサンプル

複数タイムゾーンのサンプルは [sample-multiple.cc](./sample-multiple.cc)
にあります。
同時に複数のタイムゾーンを使うサンプルになっています。

以下に
[sample-multiple.cc](./sample-multiple.cc)
の一部分をいくつか示します。

デフォルトコンストラクタをタイムゾーン名無しで使うと、
現在のローカルタイムゾーンで初期化されたインスタンスが得られます。

```c++
  // Current local time zone
  integrated_tz::time_zone itz_current;
```

コンストラクタの引数にタイムゾーン名の文字列を使うと、
指定したタイムゾーンで初期化されたインスタンスが得られます。
POSIX 形式と IANA タイムゾーンデータベース形式双方を使うことができます。

```c++
  // Asia/Tokyo (IANA time zone database style)
  integrated_tz::time_zone itz_Tokyo {"Asia/Tokyo"};
```

```c++
  // JST-9 (POSIX style)
  integrated_tz::time_zone itz_jst {"JST-9"};
```

以下、出力の例です。

```
$ ./sample-multiple
name:
    JST-9
zoned_time:
    2018-08-19 08:57:39.743906900 JST
RFC3339 (zoned):
    2018-08-19T08:57:39.743906900+09:00

name:
    Asia/Tokyo
zoned_time:
    2018-08-19 08:57:39.743906900 JST
RFC3339 (zoned):
    2018-08-19T08:57:39.743906900+09:00

name:
    JST-9
zoned_time:
    2018-08-19 08:57:39.743906900 JST
RFC3339 (zoned):
    2018-08-19T08:57:39.743906900+09:00

name:
    PST8PDT
zoned_time:
    2018-08-18 16:57:39.743906900 PDT
RFC3339 (zoned):
    2018-08-18T16:57:39.743906900-07:00

name:
    CST-9:30CDT
zoned_time:
    2018-08-19 09:27:39.743906900 CST
RFC3339 (zoned):
    2018-08-19T09:27:39.743906900+09:30

name:
    EST+5EDT,M3.2.0/2,M11.1.0/2
zoned_time:
    2018-08-18 19:57:39.743906900 EDT
RFC3339 (zoned):
    2018-08-18T19:57:39.743906900-04:00

name:
    America/Los_Angeles
zoned_time:
    2018-08-18 16:57:39.743906900 PDT
RFC3339 (zoned):
    2018-08-18T16:57:39.743906900-07:00

name:
    America/New_York
zoned_time:
    2018-08-18 19:57:39.743906900 EDT
RFC3339 (zoned):
    2018-08-18T19:57:39.743906900-04:00

name:
    Australia/Adelaide
zoned_time:
    2018-08-19 09:27:39.743906900 ACST
RFC3339 (zoned):
    2018-08-19T09:27:39.743906900+09:30


$ ./sample-multiple 1951-08-01T12:34:56+09:00
name:
    JST-9
zoned_time:
    1951-08-01 12:34:56.000000000 JST
RFC3339 (zoned):
    1951-08-01T12:34:56.000000000+09:00

name:
    Asia/Tokyo
zoned_time:
    1951-08-01 13:34:56.000000000 JDT
RFC3339 (zoned):
    1951-08-01T13:34:56.000000000+10:00

name:
    JST-9
zoned_time:
    1951-08-01 12:34:56.000000000 JST
RFC3339 (zoned):
    1951-08-01T12:34:56.000000000+09:00

name:
    PST8PDT
zoned_time:
    1951-07-31 19:34:56.000000000 PST
RFC3339 (zoned):
    1951-07-31T19:34:56.000000000-08:00

name:
    CST-9:30CDT
zoned_time:
    1951-08-01 13:04:56.000000000 CST
RFC3339 (zoned):
    1951-08-01T13:04:56.000000000+09:30

name:
    EST+5EDT,M3.2.0/2,M11.1.0/2
zoned_time:
    1951-07-31 23:34:56.000000000 EDT
RFC3339 (zoned):
    1951-07-31T23:34:56.000000000-04:00

name:
    America/Los_Angeles
zoned_time:
    1951-07-31 20:34:56.000000000 PDT
RFC3339 (zoned):
    1951-07-31T20:34:56.000000000-07:00

name:
    America/New_York
zoned_time:
    1951-07-31 23:34:56.000000000 EDT
RFC3339 (zoned):
    1951-07-31T23:34:56.000000000-04:00

name:
    Australia/Adelaide
zoned_time:
    1951-08-01 13:04:56.000000000 ACST
RFC3339 (zoned):
    1951-08-01T13:04:56.000000000+09:30


```

## このライブラリについて

なぜこのライブラリを作ったのか説明します。

### 環境変数 `TZ` と標準コマンド

Linux などについている標準コマンドで日時を扱うもの、
例えば `date` コマンドは環境変数 `TZ` を用いて
タイムゾーンを指定できるようになっています。
この際に、 `TZ` に設定する文字列は POSIX 形式でも、
IANA タイムゾーンデータベース形式でも、どちらでも受け付けられると思います。
例えば、日本標準時の場合、 POSIX 形式ならば `JST-9` と設定し、
IANA タイムゾーンデータベース形式ならば `Asia/Tokyo` と設定します。
以下、実行例です。

```
$ TZ=JST-9 date
Sat Aug 18 15:51:17 JST 2018

$ TZ=Asia/Tokyo date
Sat Aug 18 15:51:23 JST 2018

```

`TZ` に何も指定されていなかったり、解釈できない文字列が指定されている場合は、
デフォルトのタイムゾーン（この場合は GMT）が指定されたものとして動作します。

```
$ TZ= date
Sat Aug 18 06:53:59 GMT 2018

$ TZ=foobar date
Sat Aug 18 06:54:03 GMT 2018

```

POSIX 形式はサマータイム（夏時間）に関する複雑な指定もできます。
ですが、日本語の記事では `JST-9` といった
サマータイムを含まない指定方法しか触れていないものが多く、
日本のプログラムやライブラリにはサマータイムを含んだ指定を受け付けないものも
あるようです。

### 従来の方法

これと同じようなことを自分でプログラミングするときには
どうすればよいでしょうか。
プログラムの最初に
`tzset ()`
でタイムゾーン情報を初期化しておき、
`localtime ()`, `gmtime ()`, `mktime ()`, `strftime ()`
などを使って時刻を扱うようにすれば実現できそうです。
いまどきはスレッドセーフ版の
`localtime_r ()`, `gmtime_r ()`
などの方を使うべきかもしれません。

これらをうまく使うことによって、
環境変数 `TZ` でタイムゾーン指定できるようになりますし、
（OS など環境によるかもしれませんが）
標準コマンドと同じように POSIX 形式でも、
IANA タイムゾーンデータベース形式でも、
また、サマータイムの指定を含んだ複雑な POSIX 形式でも、
ちゃんと扱うことができるようになるはずです。

### 従来の方法の問題

従来の方法では `tzset ()` 実行時の環境変数 `TZ` で
「現在のタイムゾーン」を設定し、
`localtime ()`　などが設定されたタイムゾーンに従って動作することになります。
扱いたいのが「現在の場所」かつ「現在の日時」であれば
「現在のタイムゾーン」で問題ありません。
ですが、違う場所の日時を扱いたい場合や、
過去や未来の日時を扱いたい場合に問題が発生する可能性があります。
場所が違えばタイムゾーンが違うかもしれませんし、
日時が違えばサマータイム実施期間中か否かが変わって
タイムゾーンが違うかもしれません。

環境変数はプロセス毎に変えられます。
ですので、標準コマンドのように単純な機能しかなくて
単一のタイムゾーンのみ扱うのであれば、
コマンド起動の度に扱いたいタイムゾーンを指定するよう
環境変数を変えてしまえばよいことになります。
ですが、複数の場所や複数の日時を扱うため
複数のタイムゾーンが必要になる、ということもあるでしょう。

複数のタイムゾーンを扱うには、例えば
一時的に環境変数を設定したいタイムゾーンのものに変えて
`tzset ()` を呼び出し、
`localtime ()` などを使ってから、
環境変数を元に戻して再度 `tzset ()` を呼び出して元に戻す、
なんていうやり方が思い付きます。
この方法は、完全にシングルスレッドで動作するようなプログラムであれば、
あり得なくはないと思いますが、マルチスレッドだと思いっきり破綻しそうです。

### C++ 標準

`tzset ()` や `localtime ()` は
POSIX 標準で規定された C 言語用の関数です。
もちろん C++ からでも使うことはできますが、
モダンな C++ に合うかというと、そうとは言い難いのではないでしょうか。
一方、 C++11 では chrono が導入され、
C++ 標準の世界だけで共通的な時刻情報の取り扱いができるようになりました。
さらに、 C++20 では
日時やタイムゾーンを扱うことができるように拡張される
とのことです。
この C++20 で拡張される機能が実装されたコンパイラは、
2018 年 8 月現在、まだ無いようですが、
この機能を C++ 標準化委員会に提案した
Howard E. Hinnant さんによる C++11/C++14/C++17 環境向け実装が
[https://github.com/HowardHinnant/date](https://github.com/HowardHinnant/date)
にあります。
これらによってモダンな C++ で時刻情報だけでなく、
日時やタイムゾーンを扱うことができるようになります。
また、インスタンス毎に別々のタイムゾーンを設定して使うことができるので、
スレッドセーフかつ複数タイムゾーンを同時に扱うことができます。
この C++20 標準化されるタイムゾーンクラスは、
IANA タイムゾーンデータベースを使うことができます。
ですが、なぜか POSIX 形式のタイムゾーンを扱う機能が無いようなのです。
つまり、
残念なことに標準コマンドのような POSIX 形式も使えるようなコマンドが作れません。

### POSIX 形式の限界

POSIX 形式は表現できる能力に限界があります。
例えば「現在のサマータイムの規則」を記述することはできるのですが、
過去の規則を記述できません。
POSIX 形式で `JST-9` だと 2018 年 8 月の
日本時間を扱うにはまったく問題ありませんが、
1951 年 8 月の日本時間を扱うことができません。
当時はサマータイム実施中なので略称が JST ではないですし
UTC との時差が 9 時間でもないのです。
そこでサマータイムの規則も含めて、 `JST-9JDT,M5.1.6/24,M9.2.6/24`
のような指定をすると 1951 年 8 月の日本時間を扱えるようになりますが、
今度は 2018 年 8 月の日本時間が扱えません。
そこで、 IANA タイムゾーンデータベース形式の `Asia/Tokyo`
で指定しておけば、 2018 年 8 月は UTC との時差が 9 時間、
1951 年 8 月は UTC との時差 10 時間、というように正しく動作してくれる、
というわけです。
こういうことで POSIX 形式は廃れつつあって
C++ 標準に入らないのかもしれません。

### データベース

ただ、タイムゾーンデータベースは世界各地のタイムゾーンがどうなっていたか
時系列ですべて記録しているものなので、それなりに大きいものです。
また、新たに変更がある場合
（新しくサマータイムを導入する、なんていうのも変更の一つですね）
はデータベースを更新しなければなりません。
古い機器やネットワークにつながっていない機器は、
どうやって更新するんだ？ということになりそうですよね。
一応、手動で `Etc/GMT-9` や `Etc/GMT-11` といった指定ができれば、
何とかしのぐことはできるかもしれません。
ですが、サマータイムの切り替えを自分でしなければならなくなります。
JST や JDT といった略称も得られません。
個人的には `JST-9` のようにデータベース不要で
シンプルに設定できる方が好みです。
仮にサマータイムが導入されてしまっても、
データベースが更新されたかされないかを気にする必要もなく、
`JST-9` ならずっと JST になりますし、
`JST-9JDT-11,M6.1.0,M9.1.0`
（開始と終了の設定は仮のいいかげんな値です）
みたいに設定すると夏は JDT で UTC との時差 11 時間になります。

### POSIX 形式のパース

というわけで、
[https://github.com/HowardHinnant/date](https://github.com/HowardHinnant/date)
で POSIX 形式が扱えるようにならないか
[きいてみました
](https://github.com/HowardHinnant/date/issues/258)
。
そうしたら、 POSIX 形式をパースできるカスタムタイムゾーンクラス `ptz.h`
を作っていただきました。（上記の配布に含まれています。）
ただし、これは POSIX 形式を扱えるのですが、
逆に IANA タイムゾーンデータベース形式を扱えません。
そこで、両者を統合して両方を扱えるようにして、
さらにデフォルトで環境変数 `TZ` も見に行くようにしたのが本ライブラリの
タイムゾーンクラスです。

### 最後に

本稿では JST や JDT のような略称を使ってしまっていますが、
何を指しているのか曖昧になりかねないので
特にプログラム中では使わない方が良いと思います。
JST が日本標準時 Japan Standard Time ではなく
エルサレム標準時 Jerusalem Standard Time
を意味する可能性があるとか、
JDT は 1948 年から 1951 年の場合は UTC との時差 10 時間だったのに
今度は 11 時間になる可能性があるとか、
同じ略称でも別のタイムゾーンを意味することがあります。
RFC2822 や RFC3339 の時刻表現のように JST ではなく `+09:00` 、
JDT ではなく `+10:00` や `+11:00` の方が曖昧さが無くて良いと思います。

## License

Copyright (C) 2018 Masamichi Hosoda. All rights reserved.

License: BSD-2-Clause

[LICENSE](./LICENSE) をご覧ください。
